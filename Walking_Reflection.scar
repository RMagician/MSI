{==============================================================================\
|                         MSI Group Scripting Include                          |
|                           Walking_Reflection.scar                            |
|==============================================================================|
| For all the walking functions that are reflection based                      |
|                                                                              |
| * function MSI_WalkToTile(): Boolean;            * by marpis                 |
| * function MSI_RefWalk(): Boolean;               * by marpis                 |
| * function MSI_CreateRefWalk(): TWalk;           * by marpis                 |
| * function MSI_LoadRefPath(): TPointArray;       * by The MSI Team           |
| * function MSI_LoadRefWalk(): TWalk;             * by The MSI Team           |
| * function MSI_FixPosition(): Boolean;           * by marpis                 |
 \_____________________________________________________________________________}

{$IFDEF REFLECTION}

{******************************************************************************}
{ function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;     }
{ By: marpis                                                                   }
{ Description: Walks to tile                                                   }
{******************************************************************************}
function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;
var
  MP: TPoint;
begin
  MP := TileToMM(P);
  if (InCircle(MP.X, MP.Y, MMCX, MMCY, 76)) then
  begin
    MSI_Debug('MSI_WalkToTile', 'Tile on MM', DEBUG_SMALL_DETAILS);
    Result := True;
    Mouse(MP.X, MP.Y, Randomness, Randomness, True);
    MSI_Flag(FlagD);
  end else
    MSI_Debug('MSI_WalkToTile', 'Tile not on MM!', DEBUG_SMALL_DETAILS);
end;

{******************************************************************************}
{ function MSI_RefWalk(StartLoc, EndLoc: Integer): Boolean;                    }
{ By: marpis, edited by Coh3n                                                  }
{ Description: Walks from A to B                                               }
{******************************************************************************}
function MSI_RefWalk(StartLoc, EndLoc: Integer): Boolean;
var
  TheWalk: TWalk;
  I, T: Integer;
begin
  MSI_Debug('MSI_RefWalk', '', Debug_Functions);
  TheWalk := MSI_LoadRefWalk(StartLoc, EndLoc);
  T := GetSystemTime + (Length(TheWalk.RefPath) * 60 + 180) * 1000; // a minute for each tile + 3 minutes
  repeat
    for I := High(TheWalk.RefPath) downto 0 do
    begin
      if TileOnMM(TheWalk.RefPath[I]) then
        if (not MSI_WalkToTile(TheWalk.RefPath[I], 4, 10)) then
        begin
          MSI_Debug('MSI_RefWalk', 'Failed to walk to tile: ' + IntToStr(i), DEBUG_SMALL_DETAILS);
          Exit;
        end;
      Result := (I = High(TheWalk.RefPath));
      Break;
    end;
  until(Result or (GetSystemTime > T));
  if Result then
  begin
    MSI_Debug('MSI_RefWalk', 'Successfully walked!', DEBUG_SMALL_DETAILS);
    Players[CurrentPlayer].Integers[P_LOC] := TheWalk.Loc; // the ending location
  end else
    MSI_Debug('MSI_RefWalk', 'Walking failed!', DEBUG_SMALL_DETAILS);
end;

{******************************************************************************}
{ function MSI_CreateRefWalk(City, Loc: Integer; Path: TPointArray): TWalk;    }
{ By: marpis                                                                   }
{ Description: Forms TWalk from parameters                                     }
{******************************************************************************}
function MSI_CreateRefWalk(City, Loc: Integer; Path: TPointArray): TWalk;
begin
  Result.City := City;
  Result.Loc  := Loc;
  Result.RefPath := Path;
end;

{******************************************************************************}
{ function MSI_LoadRefPath(StartLoc, EndLoc: Integer): TPointArray;            }
{ By: The MSI Team                                                             }
{ Description: Loads tiles from A to B                                         }
{******************************************************************************}
function MSI_LoadRefPath(StartLoc, EndLoc: Integer): TPointArray;
begin
  case StartLoc of
    LOC_VE_BANK:
      case EndLoc of
        LOC_VE_TREES:
          Result := [ Point(3265, 3428), Point(3275, 3429), Point(3280, 3439),
                      Point(3276, 3450) ];
      end;
      
    LOC_VE_TREES:
      case EndLoc of
        LOC_VE_BANK:
          Result := [ Point(3280, 3439), Point(3276, 3428), Point(3260, 3428),
                      Point(3253, 3421) ];
      end;
  end;
end;

{******************************************************************************}
{ function MSI_LoadRefWalk(StartLoc, EndLoc: Integer): TWalk;                  }
{ By: The MSI Team                                                             }
{ Description: Loads TWalk from A to B                                         }
{******************************************************************************}
function MSI_LoadRefWalk(StartLoc, EndLoc: Integer): TWalk;
begin
  case StartLoc of
    LOC_VE_BANK:
      case EndLoc of
        LOC_VE_TREES:
          Result := MSI_CreateRefWalk(CITY_VARROCK, EndLoc, MSI_LoadRefPath(StartLoc, EndLoc));
      end;
      
    LOC_VE_TREES:
      case EndLoc of
        LOC_VE_BANK:
          Result := MSI_CreateRefWalk(CITY_VARROCK, EndLoc, MSI_LoadRefPath(StartLoc, EndLoc));
      end;
  end;
end;

{******************************************************************************}
{ function FixPosition(Location: Integer): Boolean;                            }
{ By: marpis                                                                   }
{ Description: Fix position if lost                                            }
{******************************************************************************}
function MSI_FixPosition(Location: Integer): Boolean;
begin
  Result := MSI_RefWalk(Players[CurrentPlayer].Integers[P_LOC], Location);
  if Result then
    MSI_Debug('FixPosition', 'Position fixed successfully!', DEBUG_SMALL_DETAILS)
  else
    MSI_Debug('FixPosition', 'Failed fixing position!', DEBUG_SMALL_DETAILS);
end;

{$ENDIF}

{******************************************************************************}
{ Procedure MSI_AntiBan(HowLong : Integer);                                    }
{ By: Naum, edited by Coh3n                                                    }
{ Description: The AntiBan procedure to be used throughout the scripts.        }
{******************************************************************************}
Procedure MSI_AntiBan(HowLong : Integer);
Var CurTab, I : Integer;
Begin
  Case HowLong Of
    0..2000 : Case Random(30) Of
                0 : SleepAndMoveMouse(HowLong + Random(HowLong/10));
                1 : Begin
                      CurTab := GetCurrentTab;
                      GameTab(RandomRange(TAB_Combat, TAB_LogOut));
                      Wait(HowLong + Random(HowLong/10));
                      GameTab(CurTab);
                    End;
                2 : RandomRClick;
              End;

    2001..5000 : Case Random(40) Of
                   0 : HoverSkill('Random', False);
                   1 : PickUpMouse;
                   2 : SleepAndMoveMouse(HowLong + Random(HowLong/10));
                   3 : For I := 0 To Round(HowLong/800) Do
                         If I Mod 2 = 0 Then
                           ExamineInv;
                 End;

    5001..10000 : If Random(20) = 1 Then
                    RandomMovement
                  Else
                  If Random(20) = 10 Then
                    MSI_AntiBan(Round(HowLong/2) + Random(1000));

    10001..20000 : Case Random(30) Of
                     0 : MSI_AntiBan(Round(HowLong/2) + Random(1000));
                     1 : BoredHuman;
                     2 : RandomAngle(1);
                   End;

    20001..999999 : If Random(10) = 5 Then
                      MSI_AntiBan(7000 + Random(200));
  End;
End;

{
  Unused paths:

  East Mine -> Bank
  3285, 3366
  3287, 3369
  3290, 3373
  3292, 3377
  3292, 3383
  3292, 3387
  3291, 3390
  3292, 3393
  3291, 3396
  3292, 3400
  3292, 3404
  3290, 3409
  3289, 3413
  3286, 3418
  3285, 3421
  3284, 3425
  3278, 3428
  3274, 3428
  3269, 3428
  3265, 3428
  3261, 3428
  3258, 3428
  3255, 3428
  3253, 3425
  3253, 3421
}