{==============================================================================\
|                         MSI Group Scripting Include                          |
|                           Walking_Reflection.scar                            |
|==============================================================================|
| For all the walking functions that are reflection based                      |
|                                                                              |
| * function MSI_WalkToTile(): Boolean;            * by marpis                 |
| * function MSI_ReflectionWalk(): Boolean;        * by marpis                 |
| * function MSI_CreateWalk(): TWalk;              * by marpis                 |
| * function MSI_LoadPath(): TPointArray;          * by The MSI Team           |
| * function MSI_LoadWalk(): TWalk;                * by The MSI Team           |
| * function MSI_FixPosition(): Boolean;           * by marpis                 |
 \_____________________________________________________________________________}

{$IFDEF REFLECTION}

{******************************************************************************}
{ function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;     }
{ By: marpis                                                                   }
{ Description: Walks to tile                                                   }
{******************************************************************************}
function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;
var
  MP: TPoint;
begin
  MP := TileToMM(P);
  if (InCircle(MP.X, MP.Y, MMCX, MMCY, 76)) then
  begin
    MSI_Debug('MSI_WalkToTile', 'Tile on MM', Debug_SmallDetails);
    Result := True;
    Mouse(MP.X, MP.Y, Randomness, Randomness, True);
    MSI_Flag(FlagD);
  end else
    MSI_Debug('MSI_WalkToTile', 'Tile not on MM!', Debug_SmallDetails);
end;

{******************************************************************************}
{ function MSI_ReflectionWalk(StartLoc, EndLoc: Integer): Boolean;             }
{ By: marpis                                                                   }
{ Description: Walks from A to B                                               }
{******************************************************************************}
function MSI_ReflectionWalk(StartLoc, EndLoc: Integer): Boolean;
var
  TheWalk: TWalk;
  I, T: Integer;
begin
  MSI_Debug('MSI_ReflectionWalk', '', Debug_Functions);
  TheWalk := MSI_LoadWalk(StartLoc, EndLoc);
  T := GetSystemTime + (Length(TheWalk.Path) * 60 + 180) * 1000; // a minute for each tile + 3 minutes
  repeat
    for I := High(TheWalk.Path) downto 0 do
    begin
      if TileOnMM(TheWalk.Path[I]) then
        if (not MSI_WalkToTile(TheWalk.Path[I], 4, 10)) then
          Exit;
      Result := (I = High(TheWalk.Path));
      Break;
    end;
  until(Result or (GetSystemTime > T));
  if Result then
  begin
    MSI_Debug('MSI_ReflectionWalk', 'Successfully walked!', Debug_SmallDetails);
    CurrentLocation.City := TheWalk.City;
    CurrentLocation.Loc  := TheWalk.Loc;
  end else
    MSI_Debug('MSI_ReflectionWalk', 'Walking failed!', Debug_SmallDetails);
end;

{******************************************************************************}
{ function FormWalk(City, Loc: Integer; Path: TPointArray): TWalk;             }
{ By: marpis                                                                   }
{ Description: Forms TWalk from parameters                                     }
{******************************************************************************}
function MSI_CreateWalk(City, Loc: Integer; Path: TPointArray): TWalk;
begin
  Result.City := City;
  Result.Loc  := Loc;
  Result.Path := Path;
end;

{******************************************************************************}
{ function LoadPath(StartLoc, EndLoc: Integer): TPointArray;                   }
{ By: The MSI Team                                                             }
{ Description: Loads tiles from A to B                                         }
{******************************************************************************}
function MSI_LoadPath(StartLoc, EndLoc: Integer): TPointArray;
begin
  case StartLoc of
    LOC_VE_BANK:
      case EndLoc of
        LOC_VE_TREES:
          Result := [ Point(3265, 3428), Point(3275, 3429), Point(3280, 3439),
                      Point(3276, 3450) ];
      end;
      
    LOC_VE_TREES:
      case EndLoc of
        LOC_VE_BANK:
          Result := [ Point(3280, 3439), Point(3276, 3428), Point(3260, 3428),
                      Point(3253, 3421) ];
      end;
  end;
end;

{******************************************************************************}
{ function MSI_LoadWalk(StartLoc, EndLoc: Integer): TWalk;                     }
{ By: The MSI Team                                                             }
{ Description: Loads TWalk from A to B                                         }
{******************************************************************************}
function MSI_LoadWalk(StartLoc, EndLoc: Integer): TWalk;
begin
  case StartLoc of
    LOC_VE_BANK:
      case EndLoc of
        LOC_VE_TREES:
          Result := MSI_CreateWalk(CITY_VARROCK, EndLoc, MSI_LoadPath(StartLoc, EndLoc));
      end;
      
    LOC_VE_TREES:
      case EndLoc of
        LOC_VE_BANK:
          Result := MSI_CreateWalk(CITY_VARROCK, EndLoc, MSI_LoadPath(StartLoc, EndLoc));
      end;
  end;
end;

{******************************************************************************}
{ function FixPosition(Location: Integer): Boolean;                            }
{ By: marpis                                                                   }
{ Description: Fix position if lost                                            }
{******************************************************************************}
function MSI_FixPosition(Location: Integer): Boolean;
begin
  Result := MSI_ReflectionWalk(CurrentLocation.Loc, Location);
  if Result then
    MSI_Debug('FixPosition', 'Position fixed successfully!', Debug_SmallDetails)
  else
    MSI_Debug('FixPosition', 'Failed fixing position!', Debug_SmallDetails);
end;

{$ENDIF}

{******************************************************************************}
{ Procedure MSI_AntiBan(HowLong : Integer);                                    }
{ By: Naum, edited by Coh3n                                                    }
{ Description: The AntiBan procedure to be used throughout the scripts.        }
{******************************************************************************}
Procedure MSI_AntiBan(HowLong : Integer);
Var CurTab, I : Integer;
Begin
  Case HowLong Of
    0..2000 : Case Random(30) Of
                0 : SleepAndMoveMouse(HowLong + Random(HowLong/10));
                1 : Begin
                      CurTab := GetCurrentTab;
                      GameTab(RandomRange(TAB_Combat, TAB_LogOut));
                      Wait(HowLong + Random(HowLong/10));
                      GameTab(CurTab);
                    End;
                2 : RandomRClick;
              End;

    2001..5000 : Case Random(40) Of
                   0 : HoverSkill('Random', False);
                   1 : PickUpMouse;
                   2 : SleepAndMoveMouse(HowLong + Random(HowLong/10));
                   3 : For I := 0 To Round(HowLong/800) Do
                         If I Mod 2 = 0 Then
                           ExamineInv;
                 End;

    5001..10000 : If Random(20) = 1 Then
                    RandomMovement
                  Else
                  If Random(20) = 10 Then
                    MSI_AntiBan(Round(HowLong/2) + Random(1000));

    10001..20000 : Case Random(30) Of
                     0 : MSI_AntiBan(Round(HowLong/2) + Random(1000));
                     1 : BoredHuman;
                     2 : RandomAngle(1);
                   End;

    20001..999999 : If Random(10) = 5 Then
                      MSI_AntiBan(7000 + Random(200));
  End;
End;

{
  Unused paths:

  East Mine -> Bank
  3285, 3366
  3287, 3369
  3290, 3373
  3292, 3377
  3292, 3383
  3292, 3387
  3291, 3390
  3292, 3393
  3291, 3396
  3292, 3400
  3292, 3404
  3290, 3409
  3289, 3413
  3286, 3418
  3285, 3421
  3284, 3425
  3278, 3428
  3274, 3428
  3269, 3428
  3265, 3428
  3261, 3428
  3258, 3428
  3255, 3428
  3253, 3425
  3253, 3421
}