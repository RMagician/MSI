{==============================================================================\
|                         MSI Group Scripting Include                          |
|                           Walking_Reflection.scar                            |
|==============================================================================|
| For all the walking functions that are reflection based                      |
|                                                                              |
| * function MSI_GetMyPos: TPoint;                 * by BenLand100             |
| * function MSI_TileToMM(): TPoint;               * by BenLand100             |
| * function MSI_WalkToTile(): Boolean;            * by marpis                 |
| * function MSI_LoadRefPath(): TIntegerArray;     * by The MSI Team           |
| * function MSI_RefWalk(): Boolean;               * by marpis                 |
| * function MSI_HybridWalk(): Boolean;            * by RM and Coh3n           |
| * function MSI_FixPosition(): Boolean;           * by marpis                 |
| * function MSI_PerformWalk(): Boolean;           * by Coh3n                  |
 \_____________________________________________________________________________}

{$IFDEF REFLECTION}

{******************************************************************************}
{ function MSI_GetMyPos: TPoint;                                               }
{ By: BenLand100                                                               }
{ Date: 10 June 2010                                                           }
{ Description: Calculates the player's tile position                           }
{******************************************************************************}
function MSI_GetMyPos: TPoint;
var
  me: Integer;
begin
  me := SmartGetFieldObject(0, HOOK_PLAYER);

  Result.x := SmartGetFieldInt(0, HOOK_BASE_X) + SmartGetFieldInt(me, HOOK_LOCAL_X) shr 7;
  Result.y := SmartGetFieldInt(0, HOOK_BASE_Y) + SmartGetFieldInt(me, HOOK_LOCAL_Y) shr 7;

  SmartFreeObject(me);
end;

{******************************************************************************}
{ function MSI_TileToMM(Tile: TPoint): TPoint;                                 }
{ By: BenLand100                                                               }
{ Date: 10 June 2010                                                           }
{ Description: Converts the tile position to a minimap location                }
{******************************************************************************}
function MSI_TileToMM(tile: TPoint): TPoint;
var
  angle: Extended;
  tX, tY: Integer;
  tP: TPoint;
begin
  angle:= rs_GetCompassAngleRadians;

  tP := MSI_GetMyPos;
  tX:= (tile.x - tP.x) * 4 - 2;
  tY:= (tP.y - tile.y) * 4 - 2;

  Result.x:= round(tX * cos(angle) - tY * sin(angle)) + 629;
  Result.y:= round(tX * sin(angle) + tY * cos(angle)) + 85;
end;

{******************************************************************************}
{ function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;     }
{ By: marpis                                                                   }
{ Date: 10 June 2010                                                           }
{ Description: Walks to tile                                                   }
{******************************************************************************}
function MSI_WalkToTile(P: TPoint; Randomness, FlagD: Integer): Boolean;
var
  MP: TPoint;
begin
  MP := MSI_TileToMM(P);
  if (InCircle(MP.X, MP.Y, MMCX, MMCY, 76)) then
  begin
    MSI_Debug('MSI_WalkToTile', 'Tile on MM', DEBUG_SMALL_DETAILS);
    Result := True;
    Mouse(MP.X, MP.Y, Randomness, Randomness, True);
    MSI_Flag;
  end else
    MSI_Debug('MSI_WalkToTile', 'Tile not on MM!', DEBUG_SMALL_DETAILS);
end;

{******************************************************************************}
{ function MSI_LoadRefPath(StartLoc, EndLoc: Integer): TPointArray;            }
{ By: The MSI Team                                                             }
{ Date: 10 June 2010                                                           }
{ Description: Loads tiles from A to B                                         }
{******************************************************************************}
function MSI_LoadRefPath(StartLoc, EndLoc: Integer): TPointArray;
begin
  case StartLoc of
    LOC_VE_BANK:
      case EndLoc of
        LOC_VE_TREES:
          Result := [ Point(3265, 3428), Point(3275, 3429), Point(3280, 3439),
                      Point(3276, 3450) ];
      end;
      
    LOC_VE_TREES:
      case EndLoc of
        LOC_VE_BANK:
          Result := [ Point(3280, 3439), Point(3276, 3428), Point(3260, 3428),
                      Point(3253, 3421) ];
      end;
  end;
end;

{******************************************************************************}
{ function MSI_RefWalk(StartLoc, EndLoc: Integer): Boolean;                    }
{ By: marpis, edited by Coh3n                                                  }
{ Date: 10 June 2010                                                           }
{ Description: Walks from A to B                                               }
{******************************************************************************}
function MSI_RefWalk(StartLoc, EndLoc: Integer): Boolean;
var
  ThePath: TPointArray;
  I, T: Integer;
begin
  MSI_Debug('MSI_RefWalk', '', DEBUG_FUNCTIONS);
  ThePath := MSI_LoadRefPath(StartLoc, EndLoc);
  T := GetSystemTime + (Length(ThePath) * 60 + 180) * 1000; // a minute for each tile + 3 minutes
  repeat
    for I := High(ThePath) downto 0 do
    begin
      if rs_OnMinimap(ThePath[I].x, ThePath[I].y) then
        if (not MSI_WalkToTile(ThePath[I], 4, 10)) then
        begin
          MSI_Debug('MSI_RefWalk', 'Failed to walk to tile: ' + IntToStr(i), DEBUG_SMALL_DETAILS);
          Exit;
        end;
      Result := (I = High(ThePath));
      Break;
    end;
  until(Result or (GetSystemTime > T));
  if Result then
  begin
    MSI_Debug('MSI_RefWalk', 'Successfully walked!', DEBUG_SMALL_DETAILS);
    Players[CurrentPlayer].Integers[P_LOC] := EndLoc; // the ending location
  end else
    MSI_Debug('MSI_RefWalk', 'Walking failed!', DEBUG_SMALL_DETAILS);
end;

{******************************************************************************}
{ function MSI_HybridWalk(startLoc, endLoc: Integer): Boolean;                 }
{ By: RM and Coh3n                                                             }
{ Date: 10 June 2010                                                           }
{ Description: Will walk the color path if near the reflection point. If not   }
{              near the point, will walk to the reflection tile                }
{******************************************************************************}
function MSI_HybridWalk(startLoc, endLoc: Integer): Boolean;
var
  i: Integer;
  colorPath: TIntegerArray;
  refPath: TPointArray;
  colorPoint, refPoint: TPoint;
begin
  colorPath := MSI_LoadColorPath(startLoc, endLoc);
  refPath := MSI_LoadRefPath(startLoc, endLoc);

  for i := 0 to High(colorPath) do
  begin
    colorPoint := MSI_CreateWalkIndex(colorPath[i]);
    refPoint := MSI_TileToMM(refPath[i]);

    if (Distance(refPoint.x, refPoint.y, colorPoint.x, colorPoint.y) > WALK_TOL) then
    begin
      MSI_Debug('MSI_HybridWalk', 'Color index too far off path to ' + MSI_LocToText(endLoc) + ', index ' + IntToStr(colorPath[i]), DEBUG_FUNCTIONS);
      MSI_Debug('MSI_HybridWalk', 'Using reflection backup!', DEBUG_FUNCTIONS);
      //do color gathering stuff here
      Mouse(refPoint.x, refPoint.y, 4, 4, True);
    end else
      Mouse(colorPoint.x, colorPoint.y, 4, 4, True);

    FFlag(RandomRange(3, 6));
    MSI_FindRandoms;
    
    Result := (i = High(colorPath));
  end;

  if (Result) then
  begin
    MSI_Debug('MSI_HybridWalk', 'Successfully walked to ' + MSI_LocToText(endLoc), DEBUG_SMALL_DETAILS);
    Players[CurrentPlayer].Integers[P_LOC] := endLoc;
    Wait(RandomRange(750, 1500));
  end;
end;

{******************************************************************************}
{ function FixPosition(Location: Integer): Boolean;                            }
{ By: marpis                                                                   }
{ Date: 10 June 2010                                                           }
{ Description: Fix position if lost                                            }
{******************************************************************************}
function MSI_FixPosition(Location: Integer): Boolean;
begin
  Result := MSI_RefWalk(Players[CurrentPlayer].Integers[P_LOC], Location);
  if Result then
    MSI_Debug('FixPosition', 'Position fixed successfully!', DEBUG_SMALL_DETAILS)
  else
    MSI_Debug('FixPosition', 'Failed fixing position!', DEBUG_SMALL_DETAILS);
end;

{$ENDIF}

{******************************************************************************}
{ function MSI_PerformWalk(startLoc, endLoc: Integer): Boolean;                }
{ By: Coh3n                                                                    }
{ Date: 10 June 2010                                                           }
{ Description: Performs the walking routine                                    }
{******************************************************************************}
function MSI_PerformWalk(startLoc, endLoc: Integer): Boolean;
begin
  MakeCompass('n');
  RunEnergy(20);

  {$IFDEF REFLECTION}
    Result := MSI_HybridWalk(startLoc, endLoc);
  {$ELSE}
    Result := MSI_ColorWalk(startLoc, endLoc);
  {$ENDIF}
end;

{
  Unused paths:

  East Mine -> Bank
  3285, 3366
  3287, 3369
  3290, 3373
  3292, 3377
  3292, 3383
  3292, 3387
  3291, 3390
  3292, 3393
  3291, 3396
  3292, 3400
  3292, 3404
  3290, 3409
  3289, 3413
  3286, 3418
  3285, 3421
  3284, 3425
  3278, 3428
  3274, 3428
  3269, 3428
  3265, 3428
  3261, 3428
  3258, 3428
  3255, 3428
  3253, 3425
  3253, 3421
}
