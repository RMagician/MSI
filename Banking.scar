{==============================================================================\
|                         MSI Group Scripting Include                          |
|                               Banking.scar                                   |
|==============================================================================|
| All Banking related routines.                                                |
|                                                                              |
|  Function MSI_OpenBank   *By Naum & NCDS                                     |
|  Function MSI_Deposit    *By Naum                                            |
|  Function MSI_Withdraw   *By Naum                                            |
|                                                                              |
 \_____________________________________________________________________________}

{
const
  OBJ_BANK_VE
}

{******************************************************************************}
{ Function MSI_OpenBank(Bank, tPin : String) : Boolean;                        }
{ By: Coh3n                                                                    }
{ Description: Opens the bank 'which' - refer to bank constants                }
{******************************************************************************}
function MSI_OpenBank(which: Integer; tPin: String): Boolean;
var
  theBank: TMSObject;
begin
  theBank := MSI_GetObject(which);
  if (MSI_FindObject(theBank, ClickRight)) then
  begin
    if (PinScreen) then
      if (Length(tPin) = 4) then
        InPin(tPin);

    Result := WaitFunc(@BankScreen, 200, 10000);
  end else
    MSI_Debug('MSI_OpenBank', 'Could NOT open bank: ' + theBank.Name, DEBUG_FUNCTIONS);
  
  if (Result) then
    MSI_Debug('MSI_OpenBank', 'Successfuly opened bank: ' + theBank.Name, DEBUG_FUNCTIONS)
  else
    MSI_Debug('MSI_OpenBank', 'Could NOT open bank - ' + theBank.Name, DEBUG_FUNCTIONS);
end;

{******************************************************************************}
{ Function MSI_Deposit(Items, Amount : TIntegerArray) : Boolean                }
{ By: NaumanAkhlaQ                                                             }
{ Rev: 18                                                                      }
{ Date: 16 Oct 09                                                              }
{ Description: Deposits an Item using the TItem type                           }
{******************************************************************************}

Function MSI_Deposit(Items, Amount: TIntegerArray) : Boolean;
Var ATPA2 : Array Of TPointArray;  //The length is the same as items.colors
    ATPA : T2DPointArray;
    I, BX, BY, II, DX, DY, XX, YY, Tol : Integer;
    BitmapCheck, TextCheck, DTMCheck : Boolean;
    TB : TBox;

Begin
  SetArrayLength(Items, Length(Amount));
  MSI_LoadItems(Items);
  If Not WaitFunc(@BankScreen, 70, 1300) Then  //Just in case
    Exit
  Else
  For I := 0 To High(Items) Do
  Begin
    Tol := 0;
    Repeat
      BitmapCheck := FindBitmapToleranceIn(MSI_Item[Items[I]].BMP, BX, BY, MIX1, MIY1, MIX2, MIY2, Tol);
      IncEx(Tol, 5);
    Until(BitmapCheck) xOr (Tol > 40);

    If Not BitmapCheck Then
    Begin
      SetArrayLength(ATPA2, High(MSI_Item[Items[I]].Colors)+1)

      For II := 0 To High(MSI_Item[Items[I]].Colors) Do
        FindColorsTolerance(ATPA2[II], MSI_Item[Items[I]].Colors[II], MIX1, MIY1, MIX2, MIY2, 15);

      ATPA2[0] := MergeATPA(ATPA2);
      ATPA := SplitTPA(ATPA2[0], 5);

      For II := 0 To High(ATPA) Do
      Begin
        TB := IntToBox(ATPA[II][0].x - 50, ATPA[II][0].y - 50,
              ATPA[II][0].x + 43, ATPA[II][0].y + 44);

        DTMCheck := DTMRotated(MSI_Item[Items[I]].DTM, DX, DY, TB.x1, TB.y1, TB.x2, TB.y2);
        MMouse(DX, DY, 2, 3);
        TextCheck := WaitUpTextMulti(MSI_Item[Items[I]].UpText, 150+Random(30));
        If TextCheck Then Break;
      End;
    End;

    If BitmapCheck Or TextCheck Then
    Begin
      If BX + BY > 0 Then
        MMouse(BX, BY, 2, 3);

      TextCheck := WaitUpTextMulti(MSI_Item[Items[I]].UpText, 1200);
      GetMousePos(XX, YY);
      Result := TextCheck;

      If Result Then
      Begin
        Mouse(XX, YY, 0, 0, False);

        If Amount[I] >= 28 Then
          Result := WaitOption('-All', 1200);

        If InIntArray([1, 5, 10], Amount[I]) Then
          Result := WaitOption('-'+IntToStr(Amount[I]), 1200)
        Else
        Begin
          If WaitOption('-X', 900) Then
           If WaitColor(254, 401, ClBlack, 0, 1200) Then
             TypeSend(IntToStr(Amount[I]));

             Result := True;
        End;

        If Result Then Exit;

       MSI_Debug('MSI_Deposit', 'Deposited Amount '+IntToStr(Amount[I])+
                 ' Of Item : ''' +MSI_Item[Items[I]].Name+'''', Debug_SmallDetails);
      End;
    End;
  End;
End;


{******************************************************************************}
{ Function MSI_Withdraw(Items, Amount : TIntegerArray) : Boolean               }
{ By: NaumanAkhlaQ                                                             }
{ Rev: 18                                                                      }
{ Date: 16 Oct 09                                                              }
{ Description: Widthraws an Item using the TItem type                          }
{******************************************************************************}

Function MSI_Withdraw(Items, Amount : TIntegerArray) : Boolean;
Var ATPA2 : Array Of TPointArray;  //The length is the same as items.colors
    ATPA : T2DPointArray;
    I, BX, BY, II, DX, DY, XX, YY, Tol : Integer;
    BitmapCheck, TextCheck, DTMCheck : Boolean;
    WithdrawP : TPoint;
    TB : TBox;

Begin
  MSI_LoadItems(Items);
  If Not WaitFunc(@BankScreen, 70, 1300) Then  //Just in case
    Exit
  Else
  For I := 0 To High(Items) Do
  Begin
    Tol := 0;
    Repeat
      BitmapCheck := FindBitmapToleranceIn(MSI_Item[Items[I]].BMP, BX, BY, MBX1, MBY1, MBX2, MBY2, Tol);
      IncEx(Tol, 5);
    Until(BitmapCheck) xOr (Tol > 40);

    If Not BitmapCheck Then
    Begin
      SetArrayLength(ATPA2, High(MSI_Item[Items[I]].Colors)+1)

      For II := 0 To High(MSI_Item[Items[I]].Colors) Do
        FindColorsTolerance(ATPA2[II], MSI_Item[Items[I]].Colors[II], MBX1, MBY1, MBX2, MBY2, 15);

      ATPA2[0] := MergeATPA(ATPA2);
      ATPA := SplitTPA(ATPA2[0], 5);

      For II := 0 To High(ATPA) Do
      Begin
        TB := IntToBox(ATPA[II][0].x - 50, ATPA[II][0].y - 50,
              ATPA[II][0].x + 50, ATPA[II][0].y + 50);

        DTMCheck := DTMRotated(MSI_Item[Items[I]].DTM, DX, DY, TB.x1, TB.y1, TB.x2, TB.y2);
        MMouse(DX, DY, 2, 3);
        TextCheck := WaitUpTextMulti(MSI_Item[Items[I]].UpText, 150+Random(30));
        If TextCheck Then Break;
      End;
    End;

    If BitmapCheck Or TextCheck Then
    Begin
      If BX + BY > 0 Then
        MMouse(BX, BY, 2, 3);

      TextCheck := WaitUpTextMulti(MSI_Item[Items[I]].UpText, 1200);
      GetMousePos(XX, YY);
      Result := TextCheck;

      If Result Then
      Begin
        MSI_Item[Items[I]].ItemP := Point(XX, YY);
        WithDrawP := MSTPointToBankPoint(Point(XX, YY));
        Withdraw(WithDrawP.X, WithDrawP.Y, Amount[I]);
        MSI_Debug('MSI_Withdraw', 'Withdrew Amount '+IntToStr(Amount[I])+
                 ' Of Item : ''' +MSI_Item[Items[I]].Name+'''', Debug_SmallDetails);
      End;
    End;
  End;
End;