{==============================================================================\
|                         MSI Group Scripting Include                          |
|                              AutoColors.scar                                 |
|==============================================================================|
| AutoColor routines for whatever fits our needs.                              |
|                                                                              |
| * function ChooseAutoColor(Which: Integer): TIntegerArray;                   | * by Coh3n
| * function CircleTPA(cX, cY, r: Integer): TPointArray;                       | * by Nava2
| * function srl_ReturnMMTPA: TPointArray;                                     | * by Nava2
| * function MSI_Find(Which: Integer): Integer;                                | * by Nava2
|                                                                              |
 \_____________________________________________________________________________}

{ const AutoColor Constants;
  Description: Constants representing the different types of AutoColors. }
const
  VarrockRoadColor = 0;
  
  {
   .
   .
   .
  }

{ const RGB Constants;
  Description: Constants representing the placement of RGB ranges in the
               ChooseAutoColor array. }
const
  minR = 0;
  maxR = 1;
  minG = 2;
  maxG = 3;
  minB = 4;
  maxB = 5;

var
  srl_MMTPA: TPointArray;

{*******************************************************************************
function ChooseAutoColor(Which: Integer): TIntegerArray;
By: Coh3n
Rev: 38
Date: 8 Dec 09
Description: Creates an array of the RGB ranges to use in the autocolor function.
*******************************************************************************}
function ChooseAutoColor(Which: Integer): TIntegerArray;
begin
  case Which of
  
    VarrockRoadColor:
      Result := [{minR} 128, {maxR} 145, {minG} 129, {maxG} 143, {minB} 123, {maxB} 139];

    {
     .
     .
     .
    }

    else
      MSI_Debug('ChooseAutoColor', 'Not a vaild minimap color. ', warn_Debug);
  end;
end;

{*******************************************************************************
function CircleTPA(cX, cY, r: Integer): TPointArray;
By: Nava2
Rev: 38
Date: 8 Dec 09
Description: Creates a TPA of a circle with radius 'r' and center point cX, cY.
*******************************************************************************}
function CircleTPA(cX, cY, r: Integer): TPointArray;
var
  i, j, l, tX, tY: Integer;
begin
  setLength(Result, 4 * r * r);
  l := 2 * r - 1;
  tX := cX - r;
  tY := cY - r;
  for i := 0 to l do
    for j := 0 to l do
      Result[j + l * i] := Point(tX + i, tY + j);

  Result := RemoveDistTPointArray(cX, cY, r, Result, True);
end;

{*******************************************************************************
function srl_ReturnMMTPA: TPointArray;
By: Nava2
Rev: 38
Date: 8 Dec 09
Description: Performs CircleTPA for the RS minimap.
*******************************************************************************}
function srl_ReturnMMTPA: TPointArray;
begin
  if High(srl_MMTPA) < 0 then
  begin
    Result := CircleTPA(MMCX, MMCY, (MMX2 - MMX1) div 2);
    srl_MMTPA := Result;
  end else
    Result := srl_MMTPA;
end;

{*******************************************************************************
function MSI_Find(Which: Integer): Integer;
By: Nava2, edited by Coh3n
Rev: 38
Date: 8 Dec 09
Description: Finds best color on the minimap, depending on the RGB ranges.
*******************************************************************************}
function MSI_Find(Which: Integer): Integer;
var
  R, G, B: Integer;
  i, h, c, curMax, j: Integer;
  t: TPointArray;
  CycleCols, newCols, colorCounts, Color: TIntegerArray;
begin
  Color := ChooseAutoColor(Which);

  { Get all the colours in the minimap. }
  CycleCols := GetColors(srl_ReturnMMTPA);
  ClearSameIntegers(CycleCols);

  { Cycle through creating a new array based on the inputted RGB max/mins. }
  h := High(CycleCols);
  setLength(newCols, h + 1);
  for i := 0 to h do
  begin
    ColorToRGB(CycleCols[i], R, G, B);

    if (InRange(R, Color[minR], Color[maxR]) and
        InRange(G, Color[minG], Color[maxG]) and
        InRange(B, Color[minB], Color[maxB])) then
    begin
      newCols[c] := CycleCols[i];
      Inc(c);
    end;

  end;

  setLength(newCols, c);
  setLength(colorCounts, c);
  Dec(c);

  {
    Use the colour which is most common. Could be substituted to use other
    means to pick the right colour post-RGB checks. (Density, TPA spread, etc.)
  }
  for i := 0 to c do
  begin
    FindColors(t, newCols[i], MMX1, MMY1, MMX2, MMY2);
    h := Length(t);
    if (h > curMax) then
    begin
      j := i;
      curMax := h;
    end;
  end;

  Result := newCols[j];
  Writeln('Found Color: ' + IntToStr(Result));
end;